(* Let's consider optimized version of spwoer *)

(* SPOILER1: run-time expression can carry classifiers *)
let square(x:int) : int@g1 = x * x in

(* SPOILER2: code types can refer to classifiers of run-time environment *)
let rec spower_[g2:>g1](n:int)(xq:<int@g2>) : <int@g2> @ g3 =
  if n == 0 then
   `{@g2 1 }
  else if n mod 2 == 1 then
   `{@g2 ~xq * ~{spower_@@g2 (n - 1) xq }}
  else
   (* we can use square inside quote, (as long as classifier is consistent)
      apparently cross-stage persistence *)
   `{@g2 square ~{spower_@@g2 (n / 2) xq} } in

let spower(n:int) : <int->int@g1> =
  `{@g1 fun(x:int@g4) -> ~{spower_@@g4 n `{@g4 x }}} in

~0{
  spower 5
  (* evaluates to `{@g1 fun(x:int) -> x * square (square x) } *)
} 3
(* And we can perform run-time evaluation on open code!
 * This is safe because square is defined,
 * and it can be confirmed statically
 *   type of spower 5: <int@g1>
 *   current classifier: g3 (where g1 <: g3)
 *)

