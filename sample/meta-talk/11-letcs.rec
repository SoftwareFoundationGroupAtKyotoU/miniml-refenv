(* There is another form of CSP what we call cross-stage definitions.
 * It is natural to assume that library functions are shared across stages.
 * let cs can provide similar functionality.
 *)

let cs square(x:int) : int@g1 = x * x in

let rec spower_[g2:>g1](n:int)(xq:<int@g2>) : <int@g2> =
  if n == 0 then
   `{@g2 1 }
  else if n mod 2 == 1 then
   `{@g2 ~xq * ~{spower_@@g2 (n - 1) xq }}
  else
   (* Here square is used in future-stage code fragment *)
   `{@g2 square ~{spower_@@g2 (n / 2) xq} } in

let spower(n:int) : <int->int@g1> =
  `{@g1 fun(x:int@g3) -> ~{spower_@@g3 n `{@g3 x }}} in

spower 5
(* evaluates to

  `{@g1 fun(x:int) -> x * square (square x) }

  and cross-stage definition will be copied over, resulting

  `{@!
      let cs square(x:int) : int@g1 = x * x in
      fun(x:int) -> x * square (square x)
   }

  (* note that classifier has changed from g1 to ! *)
*)
